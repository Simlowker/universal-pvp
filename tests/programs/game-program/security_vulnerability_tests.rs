use anchor_lang::prelude::*;
use anchor_lang::solana_program::test_validator::*;
use solana_program_test::*;
use solana_sdk::{
    account::Account,
    signature::{Keypair, Signer},
    transaction::Transaction,
};

use game_program::{
    instruction as game_instruction,
    state::*,
    error::GameError,
};

/// Test suite for security vulnerability fixes
#[cfg(test)]
mod security_tests {
    use super::*;

    /// Test reentrancy attack protection in claim_rewards
    #[tokio::test]
    async fn test_reentrancy_protection_claim_rewards() {
        let program_test = ProgramTest::new(
            "game_program",
            game_program::id(),
            processor!(game_program::entry),
        );
        
        let (mut banks_client, payer, recent_blockhash) = program_test.start().await;
        
        // Setup test accounts
        let staker = Keypair::new();
        let stake_account = Keypair::new();
        let mint = Keypair::new();
        let mint_authority = Keypair::new();
        let token_program = anchor_spl::token::ID;
        
        // Create a stake account with reentrancy guard
        let create_stake_ix = game_instruction::create_stake_account(
            &payer.pubkey(),
            &staker.pubkey(),
            &stake_account.pubkey(),
            &mint.pubkey(),
            1000, // amount
            3600, // duration (1 hour)
        );
        
        let mut transaction = Transaction::new_with_payer(
            &[create_stake_ix],
            Some(&payer.pubkey()),
        );
        transaction.sign(&[&payer, &staker, &stake_account], recent_blockhash);
        
        banks_client.process_transaction(transaction).await.unwrap();
        
        // Attempt to claim rewards (first call should succeed)
        let claim_rewards_ix = game_instruction::claim_rewards(
            &staker.pubkey(),
            &stake_account.pubkey(),
            &mint.pubkey(),
            &mint_authority.pubkey(),
            &token_program,
        );
        
        let mut transaction = Transaction::new_with_payer(
            &[claim_rewards_ix.clone()],
            Some(&staker.pubkey()),
        );
        transaction.sign(&[&staker], recent_blockhash);
        
        // First call should succeed
        banks_client.process_transaction(transaction).await.unwrap();
        
        // Simulate reentrancy attack by trying to call claim_rewards again
        // before the first call completes (this should fail)
        let mut reentrancy_transaction = Transaction::new_with_payer(
            &[claim_rewards_ix],
            Some(&staker.pubkey()),
        );
        reentrancy_transaction.sign(&[&staker], recent_blockhash);
        
        let result = banks_client.process_transaction(reentrancy_transaction).await;
        
        // Should fail with reentrancy detected error
        assert!(result.is_err());
        // Verify the specific error is ReentrancyDetected
        // Note: In actual test, you'd check the specific error code
    }

    /// Test integer overflow protection in execute_action
    #[tokio::test]
    async fn test_integer_overflow_protection() {
        let program_test = ProgramTest::new(
            "game_program",
            game_program::id(),
            processor!(game_program::entry),
        );
        
        let (mut banks_client, payer, recent_blockhash) = program_test.start().await;
        
        // Setup test accounts for a match
        let player1 = Keypair::new();
        let player2 = Keypair::new();
        let match_account = Keypair::new();
        
        // Create a match with players that have near-maximum stats
        let create_match_ix = game_instruction::create_match(
            &payer.pubkey(),
            &match_account.pubkey(),
            game_program::state::MatchConfig::default(),
        );
        
        let mut transaction = Transaction::new_with_payer(
            &[create_match_ix],
            Some(&payer.pubkey()),
        );
        transaction.sign(&[&payer, &match_account], recent_blockhash);
        
        banks_client.process_transaction(transaction).await.unwrap();
        
        // Create player profiles with very high stats to trigger potential overflow
        let high_stats = PlayerStats {
            health: u32::MAX - 1000,
            attack: u32::MAX - 1000,
            defense: u32::MAX - 1000,
            speed: u32::MAX - 1000,
            mana: u32::MAX - 1000,
        };
        
        // Try to execute actions that would cause integer overflow
        let combat_action = CombatAction {
            action_type: ActionType::SpecialAbility,
            target: player2.pubkey(),
            power: u32::MAX, // This should trigger overflow protection
            mana_cost: 50,
        };
        
        let execute_action_ix = game_instruction::execute_action(
            &player1.pubkey(),
            &match_account.pubkey(),
            combat_action,
        );
        
        let mut transaction = Transaction::new_with_payer(
            &[execute_action_ix],
            Some(&player1.pubkey()),
        );
        transaction.sign(&[&player1], recent_blockhash);
        
        let result = banks_client.process_transaction(transaction).await;
        
        // Should fail with arithmetic overflow error instead of wrapping around
        assert!(result.is_err());
        // Verify the specific error is ArithmeticOverflow
    }

    /// Test admin access control
    #[tokio::test]
    async fn test_admin_access_control() {
        let program_test = ProgramTest::new(
            "game_program",
            game_program::id(),
            processor!(game_program::entry),
        );
        
        let (mut banks_client, payer, recent_blockhash) = program_test.start().await;
        
        // Setup accounts
        let super_admin = Keypair::new();
        let regular_user = Keypair::new();
        let admin_config_account = Keypair::new();
        let match_account = Keypair::new();
        
        // Initialize admin configuration
        let admin_config = AdminConfig {
            super_admin: super_admin.pubkey(),
            admin_whitelist: vec![super_admin.pubkey()],
            role_assignments: vec![(super_admin.pubkey(), AdminRole::SuperAdmin)],
            emergency_stop_enabled: false,
        };
        
        // Try to execute admin function with regular user (should fail)
        let emergency_stop_ix = game_instruction::emergency_stop_match(
            &regular_user.pubkey(),
            &admin_config_account.pubkey(),
            &match_account.pubkey(),
            123, // match_id
            "Test emergency stop".to_string(),
        );
        
        let mut transaction = Transaction::new_with_payer(
            &[emergency_stop_ix],
            Some(&regular_user.pubkey()),
        );
        transaction.sign(&[&regular_user], recent_blockhash);
        
        let result = banks_client.process_transaction(transaction).await;
        
        // Should fail with access denied error
        assert!(result.is_err());
        
        // Try the same operation with super admin (should succeed)
        let admin_emergency_stop_ix = game_instruction::emergency_stop_match(
            &super_admin.pubkey(),
            &admin_config_account.pubkey(),
            &match_account.pubkey(),
            123, // match_id
            "Admin emergency stop".to_string(),
        );
        
        let mut admin_transaction = Transaction::new_with_payer(
            &[admin_emergency_stop_ix],
            Some(&super_admin.pubkey()),
        );
        admin_transaction.sign(&[&super_admin], recent_blockhash);
        
        // This should succeed (assuming proper setup)
        let admin_result = banks_client.process_transaction(admin_transaction).await;
        
        // Should succeed for valid admin
        assert!(admin_result.is_ok());
    }

    /// Test that admin whitelist validation works
    #[tokio::test]
    async fn test_admin_whitelist_validation() {
        let program_test = ProgramTest::new(
            "game_program",
            game_program::id(),
            processor!(game_program::entry),
        );
        
        let (mut banks_client, payer, recent_blockhash) = program_test.start().await;
        
        let super_admin = Keypair::new();
        let unauthorized_admin = Keypair::new();
        let admin_config_account = Keypair::new();
        
        // Create admin config with limited whitelist
        let admin_config = AdminConfig {
            super_admin: super_admin.pubkey(),
            admin_whitelist: vec![super_admin.pubkey()], // Only super_admin is whitelisted
            role_assignments: vec![(super_admin.pubkey(), AdminRole::SuperAdmin)],
            emergency_stop_enabled: false,
        };
        
        // Try to update admin config with unauthorized admin
        let update_config_ix = game_instruction::update_admin_config(
            &unauthorized_admin.pubkey(),
            &admin_config_account.pubkey(),
            vec![unauthorized_admin.pubkey()], // Try to add self to whitelist
            vec![], // No role updates
        );
        
        let mut transaction = Transaction::new_with_payer(
            &[update_config_ix],
            Some(&unauthorized_admin.pubkey()),
        );
        transaction.sign(&[&unauthorized_admin], recent_blockhash);
        
        let result = banks_client.process_transaction(transaction).await;
        
        // Should fail because unauthorized_admin is not the super admin
        assert!(result.is_err());
    }

    /// Test checks-effects-interactions pattern implementation
    #[tokio::test]
    async fn test_checks_effects_interactions_pattern() {
        // This test verifies that state changes happen before external calls
        // which prevents reentrancy attacks and ensures consistency
        
        let program_test = ProgramTest::new(
            "token_program",
            token_program::id(),
            processor!(token_program::entry),
        );
        
        let (mut banks_client, payer, recent_blockhash) = program_test.start().await;
        
        // Setup stake account
        let staker = Keypair::new();
        let stake_account = Keypair::new();
        
        // Verify that claim_rewards updates state before making external token mint call
        // by checking that even if the mint call fails, the state changes are rolled back
        
        // Create stake account with pending rewards
        // ... setup code ...
        
        // Call claim_rewards and verify that state is updated atomically
        // Either all state changes succeed, or they all fail (no partial updates)
        
        // This is more of an integration test that would require
        // monitoring state changes during execution
        assert!(true); // Placeholder - actual test would verify state consistency
    }

    /// Test that arithmetic operations use checked math
    #[tokio::test] 
    async fn test_checked_arithmetic_operations() {
        // Test various scenarios where arithmetic operations could overflow
        let test_cases = vec![
            (u32::MAX, 1, true),        // Should overflow
            (u32::MAX - 1, 1, false),  // Should not overflow
            (0, 1, false),             // Basic addition
            (100, 200, false),         // Normal case
        ];
        
        for (a, b, should_fail) in test_cases {
            let result = a.checked_add(b);
            if should_fail {
                assert!(result.is_none(), "Expected overflow for {} + {}", a, b);
            } else {
                assert!(result.is_some(), "Expected success for {} + {}", a, b);
            }
        }
        
        // Test multiplication overflow cases
        let mult_cases = vec![
            (u32::MAX / 2 + 1, 2, true),  // Should overflow
            (u32::MAX / 2, 2, false),     // Should not overflow
            (100, 200, false),            // Normal case
        ];
        
        for (a, b, should_fail) in mult_cases {
            let result = a.checked_mul(b);
            if should_fail {
                assert!(result.is_none(), "Expected overflow for {} * {}", a, b);
            } else {
                assert!(result.is_some(), "Expected success for {} * {}", a, b);
            }
        }
    }

    /// Performance test to ensure security fixes don't significantly impact performance
    #[tokio::test]
    async fn test_security_fixes_performance_impact() {
        use std::time::Instant;
        
        // Benchmark basic operations with security fixes
        let iterations = 1000;
        
        // Test checked arithmetic performance
        let start = Instant::now();
        for i in 0..iterations {
            let _result = (i as u32).checked_add(1).unwrap_or(0);
        }
        let checked_duration = start.elapsed();
        
        // Test regular arithmetic (for comparison)
        let start = Instant::now();
        for i in 0..iterations {
            let _result = (i as u32).wrapping_add(1);
        }
        let regular_duration = start.elapsed();
        
        // Security overhead should be minimal (less than 2x slower)
        let overhead_ratio = checked_duration.as_nanos() as f64 / regular_duration.as_nanos() as f64;
        assert!(overhead_ratio < 2.0, "Security fixes add too much overhead: {}x", overhead_ratio);
        
        println!("Security overhead: {:.2}x", overhead_ratio);
    }
}

// Helper functions for creating test instructions
mod test_helpers {
    use super::*;

    pub fn create_test_stake_account() -> StakeAccount {
        StakeAccount {
            staker: Pubkey::new_unique(),
            amount: 1000,
            staked_at: 0,
            duration: 3600,
            last_claim_at: 0,
            total_rewards_claimed: 0,
            is_active: true,
            reentrancy_guard: ReentrancyState::NotEntered,
            bump: 255,
        }
    }

    pub fn create_test_admin_config() -> AdminConfig {
        let super_admin = Pubkey::new_unique();
        AdminConfig {
            super_admin,
            admin_whitelist: vec![super_admin],
            role_assignments: vec![(super_admin, AdminRole::SuperAdmin)],
            emergency_stop_enabled: false,
        }
    }
}