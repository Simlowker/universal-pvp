/**\n * Integration Tests - End-to-end SDK functionality\n */\n\nimport { Connection, PublicKey, Keypair } from '@solana/web3.js';\nimport { GameClient } from '../src/clients/game-client';\nimport { MagicBlockClient } from '../src/clients/magicblock-client';\nimport { VRFClient } from '../src/vrf/vrf-client';\nimport { TEEAttestationVerifier } from '../src/tee/attestation';\nimport {\n  GameClientConfig,\n  GameAction,\n  ActionType,\n  WinnerSelectionConfig\n} from '../src/types';\n\n// Mock external dependencies for integration tests\njest.mock('@magicblock-labs/ephemeral-rollups-sdk');\njest.mock('@magicblock-labs/bolt-sdk');\n\ndescribe('SDK Integration Tests', () => {\n  let gameClient: GameClient;\n  let magicBlockClient: MagicBlockClient;\n  let vrfClient: VRFClient;\n  let connection: Connection;\n  let config: GameClientConfig;\n  let players: PublicKey[];\n\n  beforeAll(async () => {\n    connection = new Connection('http://localhost:8899', 'confirmed');\n    \n    players = [\n      Keypair.generate().publicKey,\n      Keypair.generate().publicKey,\n      Keypair.generate().publicKey,\n      Keypair.generate().publicKey\n    ];\n    \n    config = {\n      connection,\n      rollupUrl: 'http://localhost:8900',\n      chainId: 1,\n      gaslessEnabled: true,\n      sessionTimeout: 300000, // 5 minutes\n      maxRetries: 3,\n      vrf: {\n        curve: 'edwards25519',\n        hashSuite: 'sha512',\n        latencyTarget: 10\n      },\n      session: {\n        maxDuration: 300000,\n        gaslessTransactions: true,\n        autoRenew: true,\n        batchSize: 10\n      },\n      teeVerification: true\n    };\n  });\n\n  beforeEach(async () => {\n    gameClient = new GameClient(config);\n    magicBlockClient = new MagicBlockClient(config);\n    vrfClient = new VRFClient(config.vrf);\n    \n    await Promise.all([\n      gameClient.initialize(),\n      magicBlockClient.initialize(),\n      vrfClient.initialize()\n    ]);\n  });\n\n  afterEach(async () => {\n    await Promise.all([\n      gameClient.close(),\n      magicBlockClient.close()\n    ]);\n  });\n\n  describe('Full Game Flow', () => {\n    test('should complete a full game with VRF and TEE verification', async () => {\n      // Step 1: Create match with rollup session\n      const { match, rollupId } = await gameClient.createMatch(players.slice(0, 2), {\n        computeBudget: 2_000_000,\n        lifetimeMs: 300000,\n        enableVRF: true,\n        requireTEE: true\n      });\n      \n      expect(match.id).toBeDefined();\n      expect(rollupId).toBeDefined();\n      \n      // Step 2: Execute multiple game actions with VRF\n      const actions: GameAction[] = [\n        {\n          type: ActionType.Move,\n          player: players[0],\n          data: { position: { x: 1, y: 1 } },\n          timestamp: Date.now()\n        },\n        {\n          type: ActionType.Attack,\n          player: players[1],\n          data: { target: players[0], damage: 25 },\n          timestamp: Date.now() + 1000\n        },\n        {\n          type: ActionType.Special,\n          player: players[0],\n          data: { ability: 'fireball', mana: 50 },\n          timestamp: Date.now() + 2000\n        }\n      ];\n      \n      const actionResults = [];\n      \n      for (const action of actions) {\n        // Create TEE attestation for critical actions\n        let attestation;\n        if (action.type === ActionType.Attack || action.type === ActionType.Special) {\n          attestation = TEEAttestationVerifier.createTestAttestation();\n        }\n        \n        const result = await gameClient.executeGameAction(\n          match.id.toString(),\n          action,\n          attestation\n        );\n        \n        actionResults.push(result);\n        \n        expect(result.signature).toBeDefined();\n        \n        // VRF should be used for random actions\n        if (action.type === ActionType.Attack || action.type === ActionType.Special) {\n          expect(result.vrfOutput).toBeDefined();\n          expect(result.vrfOutput!.isValid).toBe(true);\n        }\n      }\n      \n      // Step 3: Select winners using VRF\n      const winnerSelection = await gameClient.selectMatchWinners(\n        match.id.toString(),\n        1,\n        [100, 150] // Player weights based on performance\n      );\n      \n      expect(winnerSelection.winners).toHaveLength(1);\n      expect(winnerSelection.proof).toBeDefined();\n      expect(winnerSelection.randomness).toBeDefined();\n      \n      // Step 4: Commit to L1\n      const commitResult = await gameClient.commitMatchToL1(match.id.toString());\n      \n      expect(commitResult.signature).toBeDefined();\n      expect(commitResult.proof).toBeDefined();\n      \n      // Verify final game state\n      const finalGameState = gameClient.getMatchState(match.id.toString());\n      expect(finalGameState!.actions).toHaveLength(3);\n      expect(finalGameState!.match.winner).toBeDefined();\n    }, 30000);\n\n    test('should handle tournament-style multi-match scenario', async () => {\n      const tournament = {\n        matches: [] as any[],\n        winners: [] as PublicKey[]\n      };\n      \n      // Create 2 matches (4 players total)\n      for (let i = 0; i < 2; i++) {\n        const matchPlayers = players.slice(i * 2, (i + 1) * 2);\n        const { match } = await gameClient.createMatch(matchPlayers);\n        tournament.matches.push(match);\n        \n        // Quick game simulation\n        const action: GameAction = {\n          type: ActionType.Attack,\n          player: matchPlayers[0],\n          data: { target: matchPlayers[1] },\n          timestamp: Date.now()\n        };\n        \n        await gameClient.executeGameAction(match.id.toString(), action);\n        \n        // Select winner\n        const winnerSelection = await gameClient.selectMatchWinners(\n          match.id.toString(),\n          1\n        );\n        \n        const winnerIndex = winnerSelection.winners[0];\n        tournament.winners.push(matchPlayers[winnerIndex]);\n      }\n      \n      // Final match between winners\n      const { match: finalMatch } = await gameClient.createMatch(tournament.winners);\n      \n      const finalAction: GameAction = {\n        type: ActionType.Special,\n        player: tournament.winners[0],\n        data: { ability: 'ultimate' },\n        timestamp: Date.now()\n      };\n      \n      await gameClient.executeGameAction(finalMatch.id.toString(), finalAction);\n      \n      const championSelection = await gameClient.selectMatchWinners(\n        finalMatch.id.toString(),\n        1\n      );\n      \n      expect(championSelection.winners).toHaveLength(1);\n      \n      // Commit all matches to L1\n      const commitPromises = [...tournament.matches, finalMatch].map(match =>\n        gameClient.commitMatchToL1(match.id.toString())\n      );\n      \n      const commitResults = await Promise.all(commitPromises);\n      expect(commitResults).toHaveLength(3);\n    }, 45000);\n  });\n\n  describe('VRF Integration', () => {\n    test('should maintain randomness integrity across multiple operations', async () => {\n      const seeds = [\n        new TextEncoder().encode('seed1'),\n        new TextEncoder().encode('seed2'),\n        new TextEncoder().encode('seed3')\n      ];\n      \n      // Generate VRF outputs\n      const outputs = await vrfClient.batchGenerate(seeds);\n      \n      // Verify each output\n      for (let i = 0; i < outputs.length; i++) {\n        const verificationResult = await vrfClient.verifyRandomness(\n          vrfClient.getPublicKey()!,\n          outputs[i].proof,\n          seeds[i]\n        );\n        \n        expect(verificationResult.isValid).toBe(true);\n        expect(verificationResult.output).toEqual(outputs[i].beta);\n        expect(verificationResult.latency).toBeLessThan(10);\n      }\n      \n      // Ensure outputs are different\n      const betas = outputs.map(o => o.beta);\n      expect(new Set(betas.map(b => b.toString())).size).toBe(3);\n    });\n\n    test('should handle weighted winner selection correctly', async () => {\n      const selectionConfig: WinnerSelectionConfig = {\n        totalParticipants: 10,\n        winnerCount: 3,\n        seed: new TextEncoder().encode('weighted_test'),\n        weights: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] // Higher weights for later players\n      };\n      \n      // Run multiple selections to test distribution\n      const selections = [];\n      for (let i = 0; i < 100; i++) {\n        const config = {\n          ...selectionConfig,\n          seed: new TextEncoder().encode(`weighted_test_${i}`)\n        };\n        \n        const result = await vrfClient.selectWinners(config);\n        selections.push(result.winners);\n      }\n      \n      // Analyze distribution\n      const winCounts = new Array(10).fill(0);\n      selections.forEach(winners => {\n        winners.forEach(winner => {\n          winCounts[winner]++;\n        });\n      });\n      \n      // Higher weighted players should win more often\n      const averageWins = winCounts.reduce((a, b) => a + b) / winCounts.length;\n      expect(winCounts[9]).toBeGreaterThan(averageWins); // Highest weight\n      expect(winCounts[0]).toBeLessThan(averageWins); // Lowest weight\n    });\n  });\n\n  describe('Session and Cost Management', () => {\n    test('should track costs across multiple operations', async () => {\n      const initialTracking = magicBlockClient.getCostTracking();\n      expect(initialTracking.totalSpent).toBe(0);\n      \n      // Perform multiple operations\n      const { match } = await gameClient.createMatch(players.slice(0, 2));\n      \n      for (let i = 0; i < 5; i++) {\n        const action: GameAction = {\n          type: ActionType.Move,\n          player: players[i % 2],\n          data: { position: { x: i, y: i } },\n          timestamp: Date.now()\n        };\n        \n        await gameClient.executeGameAction(match.id.toString(), action);\n      }\n      \n      // Check cost tracking\n      const finalTracking = magicBlockClient.getCostTracking();\n      expect(finalTracking.transactionCount).toBeGreaterThan(0);\n      expect(finalTracking.averageCost).toBeGreaterThan(0);\n    });\n\n    test('should maintain session across operations', async () => {\n      const initialSession = magicBlockClient.getSession();\n      expect(initialSession).not.toBeNull();\n      expect(initialSession!.isActive).toBe(true);\n      \n      // Perform operations that should use the same session\n      const { match } = await gameClient.createMatch(players.slice(0, 2));\n      \n      const action: GameAction = {\n        type: ActionType.Move,\n        player: players[0],\n        data: {},\n        timestamp: Date.now()\n      };\n      \n      await gameClient.executeGameAction(match.id.toString(), action);\n      \n      const currentSession = magicBlockClient.getSession();\n      expect(currentSession!.id).toBe(initialSession!.id);\n      expect(currentSession!.gaslessTransactions).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Error Handling and Recovery', () => {\n    test('should handle network failures gracefully', async () => {\n      // Simulate network issues by using invalid configuration\n      const invalidConfig = {\n        ...config,\n        rollupUrl: 'http://invalid-url:9999'\n      };\n      \n      const invalidClient = new GameClient(invalidConfig);\n      \n      // Should handle initialization failure\n      await expect(invalidClient.initialize())\n        .rejects.toThrow();\n    });\n\n    test('should validate input parameters', async () => {\n      await expect(gameClient.createMatch([]))\n        .rejects.toThrow();\n      \n      await expect(gameClient.executeGameAction('invalid-match', {\n        type: ActionType.Move,\n        player: players[0],\n        data: {},\n        timestamp: Date.now()\n      })).rejects.toThrow('Match not found');\n    });\n  });\n\n  describe('Performance Requirements', () => {\n    test('should meet latency targets for VRF operations', async () => {\n      const message = new TextEncoder().encode('performance_test');\n      const iterations = 10;\n      const latencies = [];\n      \n      for (let i = 0; i < iterations; i++) {\n        const start = performance.now();\n        await vrfClient.generateRandomness(message);\n        const latency = performance.now() - start;\n        latencies.push(latency);\n      }\n      \n      const averageLatency = latencies.reduce((a, b) => a + b) / latencies.length;\n      expect(averageLatency).toBeLessThan(config.vrf.latencyTarget);\n    });\n\n    test('should handle concurrent operations efficiently', async () => {\n      const concurrentMatches = 5;\n      const matchPromises = [];\n      \n      for (let i = 0; i < concurrentMatches; i++) {\n        const matchPlayers = [players[0], players[1]];\n        matchPromises.push(gameClient.createMatch(matchPlayers));\n      }\n      \n      const start = performance.now();\n      const matches = await Promise.all(matchPromises);\n      const duration = performance.now() - start;\n      \n      expect(matches).toHaveLength(concurrentMatches);\n      expect(duration).toBeLessThan(10000); // Should complete within 10 seconds\n      \n      // Verify all matches are unique\n      const matchIds = matches.map(({ match }) => match.id.toString());\n      expect(new Set(matchIds).size).toBe(concurrentMatches);\n    });\n  });\n\n  describe('Resource Cleanup', () => {\n    test('should clean up resources on close', async () => {\n      const { match } = await gameClient.createMatch(players.slice(0, 2));\n      \n      const initialStatus = gameClient.getStatus();\n      expect(initialStatus.activeMatches).toBe(1);\n      \n      await gameClient.close();\n      \n      const finalStatus = gameClient.getStatus();\n      expect(finalStatus.isInitialized).toBe(false);\n    });\n\n    test('should handle session expiration', (done) => {\n      const shortConfig = {\n        ...config,\n        sessionTimeout: 100 // 100ms for quick test\n      };\n      \n      const shortLivedClient = new MagicBlockClient(shortConfig);\n      \n      shortLivedClient.on('session:expired', () => {\n        expect(shortLivedClient.getSession()).toBeNull();\n        shortLivedClient.close().then(() => done());\n      });\n      \n      shortLivedClient.initialize();\n    }, 1000);\n  });\n});"