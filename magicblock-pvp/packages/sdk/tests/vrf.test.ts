/**\n * VRF Client and ECVRF Tests\n */\n\nimport { ECVRF } from '../src/vrf/ecvrf';\nimport { VRFClient } from '../src/vrf/vrf-client';\nimport { VRFConfig, WinnerSelectionConfig } from '../src/types';\n\ndescribe('ECVRF Implementation', () => {\n  let keyPair: any;\n  let message: Uint8Array;\n\n  beforeEach(() => {\n    keyPair = ECVRF.generateKeyPair();\n    message = new TextEncoder().encode('test message');\n  });\n\n  test('should generate valid key pair', () => {\n    expect(keyPair.secretKey).toBeInstanceOf(Uint8Array);\n    expect(keyPair.publicKey).toBeInstanceOf(Uint8Array);\n    expect(keyPair.secretKey.length).toBe(32);\n    expect(keyPair.publicKey.length).toBe(32);\n  });\n\n  test('should generate VRF proof', () => {\n    const output = ECVRF.prove(keyPair.secretKey, message);\n    \n    expect(output.isValid).toBe(true);\n    expect(output.beta).toBeInstanceOf(Uint8Array);\n    expect(output.beta.length).toBe(32);\n    expect(output.proof.gamma.length).toBe(32);\n    expect(output.proof.c.length).toBe(16);\n    expect(output.proof.s.length).toBe(32);\n  });\n\n  test('should verify VRF proof', () => {\n    const proofOutput = ECVRF.prove(keyPair.secretKey, message);\n    const verifyOutput = ECVRF.verify(keyPair.publicKey, proofOutput.proof, message);\n    \n    expect(verifyOutput.isValid).toBe(true);\n    expect(verifyOutput.beta).toEqual(proofOutput.beta);\n  });\n\n  test('should reject invalid proof', () => {\n    const proofOutput = ECVRF.prove(keyPair.secretKey, message);\n    \n    // Corrupt the proof\n    proofOutput.proof.c[0] ^= 1;\n    \n    const verifyOutput = ECVRF.verify(keyPair.publicKey, proofOutput.proof, message);\n    expect(verifyOutput.isValid).toBe(false);\n  });\n\n  test('should select winners proportionally', () => {\n    const participants = [10, 20, 30, 40]; // Weights\n    const winnerCount = 2;\n    const seed = new Uint8Array(32);\n    seed.fill(42);\n    \n    const winners = ECVRF.selectWinners(participants, winnerCount, seed);\n    \n    expect(winners).toHaveLength(winnerCount);\n    expect(winners.every(w => w >= 0 && w < participants.length)).toBe(true);\n    expect(new Set(winners).size).toBe(winnerCount); // No duplicates\n  });\n\n  test('should complete VRF generation within latency target', () => {\n    const start = performance.now();\n    ECVRF.prove(keyPair.secretKey, message);\n    const duration = performance.now() - start;\n    \n    expect(duration).toBeLessThan(10); // <10ms target\n  });\n});\n\ndescribe('VRF Client', () => {\n  let client: VRFClient;\n  let config: VRFConfig;\n\n  beforeEach(async () => {\n    config = {\n      curve: 'edwards25519',\n      hashSuite: 'sha512',\n      latencyTarget: 10\n    };\n    \n    client = new VRFClient(config);\n    await client.initialize();\n  });\n\n  test('should initialize successfully', () => {\n    expect(client.getPublicKey()).toBeInstanceOf(Uint8Array);\n    expect(client.getPublicKey()!.length).toBe(32);\n  });\n\n  test('should generate randomness', async () => {\n    const message = new TextEncoder().encode('test');\n    const output = await client.generateRandomness(message);\n    \n    expect(output.isValid).toBe(true);\n    expect(output.beta.length).toBe(32);\n    expect(output.proof).toBeDefined();\n  });\n\n  test('should verify randomness from another party', async () => {\n    const message = new TextEncoder().encode('test');\n    const output = await client.generateRandomness(message);\n    \n    const result = await client.verifyRandomness(\n      client.getPublicKey()!,\n      output.proof,\n      message\n    );\n    \n    expect(result.isValid).toBe(true);\n    expect(result.output).toEqual(output.beta);\n    expect(result.latency).toBeLessThan(10);\n  });\n\n  test('should select winners', async () => {\n    const config: WinnerSelectionConfig = {\n      totalParticipants: 5,\n      winnerCount: 2,\n      seed: new TextEncoder().encode('selection_test'),\n      weights: [1, 2, 3, 4, 5]\n    };\n    \n    const result = await client.selectWinners(config);\n    \n    expect(result.winners).toHaveLength(2);\n    expect(result.proof).toBeDefined();\n    expect(result.randomness.length).toBe(32);\n    expect(result.selectionTime).toBeGreaterThan(0);\n  });\n\n  test('should handle batch generation', async () => {\n    const messages = [\n      new TextEncoder().encode('msg1'),\n      new TextEncoder().encode('msg2'),\n      new TextEncoder().encode('msg3')\n    ];\n    \n    const outputs = await client.batchGenerate(messages);\n    \n    expect(outputs).toHaveLength(3);\n    outputs.forEach(output => {\n      expect(output.isValid).toBe(true);\n      expect(output.beta.length).toBe(32);\n    });\n  });\n\n  test('should track performance metrics', async () => {\n    const message = new TextEncoder().encode('metrics_test');\n    \n    // Generate some VRF outputs\n    await client.generateRandomness(message);\n    await client.generateRandomness(message);\n    \n    const metrics = client.getMetrics();\n    \n    expect(metrics.totalRequests).toBe(2);\n    expect(metrics.failedRequests).toBe(0);\n    expect(metrics.averageLatency).toBeGreaterThan(0);\n  });\n});"