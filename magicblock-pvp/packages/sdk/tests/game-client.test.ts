/**\n * Game Client Integration Tests\n */\n\nimport { Connection, PublicKey, Keypair } from '@solana/web3.js';\nimport { GameClient } from '../src/clients/game-client';\nimport { GameClientConfig, GameAction, ActionType, MatchStatus } from '../src/types';\n\n// Mock the external dependencies\njest.mock('@magicblock-labs/ephemeral-rollups-sdk');\njest.mock('@magicblock-labs/bolt-sdk');\n\ndescribe('Game Client', () => {\n  let gameClient: GameClient;\n  let config: GameClientConfig;\n  let connection: Connection;\n  let players: PublicKey[];\n\n  beforeEach(() => {\n    connection = new Connection('http://localhost:8899', 'confirmed');\n    players = [\n      Keypair.generate().publicKey,\n      Keypair.generate().publicKey\n    ];\n    \n    config = {\n      connection,\n      rollupUrl: 'http://localhost:8900',\n      chainId: 1,\n      gaslessEnabled: true,\n      sessionTimeout: 60000,\n      maxRetries: 3,\n      vrf: {\n        curve: 'edwards25519',\n        hashSuite: 'sha512',\n        latencyTarget: 10\n      },\n      session: {\n        maxDuration: 60000,\n        gaslessTransactions: true,\n        autoRenew: true,\n        batchSize: 10\n      },\n      teeVerification: false\n    };\n    \n    gameClient = new GameClient(config);\n  });\n\n  afterEach(async () => {\n    if (gameClient) {\n      await gameClient.close();\n    }\n  });\n\n  test('should initialize successfully', async () => {\n    await gameClient.initialize();\n    \n    const status = gameClient.getStatus();\n    expect(status.isInitialized).toBe(true);\n    expect(status.activeMatches).toBe(0);\n    expect(status.activePlayers).toBe(0);\n  });\n\n  test('should create a match', async () => {\n    await gameClient.initialize();\n    \n    const { match, rollupId } = await gameClient.createMatch(players, {\n      computeBudget: 1000000,\n      lifetimeMs: 30000,\n      enableVRF: true\n    });\n    \n    expect(match.id).toBeDefined();\n    expect(match.players).toEqual(players);\n    expect(match.status).toBe(MatchStatus.Pending);\n    expect(match.startTime).toBeGreaterThan(0);\n    expect(rollupId).toBeDefined();\n    \n    const gameState = gameClient.getMatchState(match.id.toString());\n    expect(gameState).not.toBeNull();\n    expect(gameState!.players).toHaveLength(2);\n    expect(gameState!.currentTurn).toEqual(players[0]);\n  });\n\n  test('should execute game action', async () => {\n    await gameClient.initialize();\n    \n    const { match } = await gameClient.createMatch(players);\n    \n    const action: GameAction = {\n      type: ActionType.Move,\n      player: players[0],\n      data: { position: { x: 1, y: 1 } },\n      timestamp: Date.now()\n    };\n    \n    const result = await gameClient.executeGameAction(match.id.toString(), action);\n    \n    expect(result.signature).toBeDefined();\n    \n    const gameState = gameClient.getMatchState(match.id.toString());\n    expect(gameState!.actions).toContain(action);\n    expect(gameState!.currentTurn).toEqual(players[1]); // Turn should advance\n  });\n\n  test('should execute action with VRF for random events', async () => {\n    await gameClient.initialize();\n    \n    const { match } = await gameClient.createMatch(players);\n    \n    const attackAction: GameAction = {\n      type: ActionType.Attack,\n      player: players[0],\n      data: { target: players[1] },\n      timestamp: Date.now()\n    };\n    \n    const result = await gameClient.executeGameAction(match.id.toString(), attackAction);\n    \n    expect(result.signature).toBeDefined();\n    expect(result.vrfOutput).toBeDefined();\n    expect(result.vrfOutput!.isValid).toBe(true);\n    expect(result.vrfOutput!.beta.length).toBe(32);\n  });\n\n  test('should select match winners', async () => {\n    await gameClient.initialize();\n    \n    const { match } = await gameClient.createMatch(players);\n    \n    const winnerSelection = await gameClient.selectMatchWinners(\n      match.id.toString(),\n      1,\n      [10, 20] // Player weights\n    );\n    \n    expect(winnerSelection.winners).toHaveLength(1);\n    expect(winnerSelection.winners[0]).toBeGreaterThanOrEqual(0);\n    expect(winnerSelection.winners[0]).toBeLessThan(players.length);\n    expect(winnerSelection.proof).toBeDefined();\n    expect(winnerSelection.randomness.length).toBe(32);\n    \n    const gameState = gameClient.getMatchState(match.id.toString());\n    expect(gameState!.match.status).toBe(MatchStatus.Completed);\n    expect(gameState!.match.winner).toBeDefined();\n    expect(gameState!.match.endTime).toBeGreaterThan(0);\n  });\n\n  test('should commit match to L1', async () => {\n    await gameClient.initialize();\n    \n    const { match } = await gameClient.createMatch(players);\n    \n    const commitResult = await gameClient.commitMatchToL1(match.id.toString());\n    \n    expect(commitResult.signature).toBeDefined();\n    expect(commitResult.proof).toBeDefined();\n  });\n\n  test('should get player matches', async () => {\n    await gameClient.initialize();\n    \n    const { match } = await gameClient.createMatch(players);\n    \n    const playerMatches = gameClient.getPlayerMatches(players[0]);\n    \n    expect(playerMatches).toHaveLength(1);\n    expect(playerMatches[0].id.toString()).toBe(match.id.toString());\n  });\n\n  test('should get player stats', async () => {\n    await gameClient.initialize();\n    \n    await gameClient.createMatch(players);\n    \n    const playerStats = gameClient.getPlayerStats(players[0]);\n    \n    expect(playerStats).not.toBeNull();\n    expect(playerStats!.publicKey).toEqual(players[0]);\n    expect(playerStats!.level).toBe(1);\n    expect(playerStats!.experience).toBe(0);\n  });\n\n  test('should validate game actions', async () => {\n    await gameClient.initialize();\n    \n    const { match } = await gameClient.createMatch(players);\n    \n    // Try to play as wrong player\n    const invalidAction: GameAction = {\n      type: ActionType.Move,\n      player: players[1], // Not their turn\n      data: { position: { x: 1, y: 1 } },\n      timestamp: Date.now()\n    };\n    \n    await expect(\n      gameClient.executeGameAction(match.id.toString(), invalidAction)\n    ).rejects.toThrow('Not player turn');\n  });\n\n  test('should handle match not found errors', async () => {\n    await gameClient.initialize();\n    \n    const action: GameAction = {\n      type: ActionType.Move,\n      player: players[0],\n      data: {},\n      timestamp: Date.now()\n    };\n    \n    await expect(\n      gameClient.executeGameAction('non-existent-match', action)\n    ).rejects.toThrow('Match not found');\n    \n    await expect(\n      gameClient.selectMatchWinners('non-existent-match', 1)\n    ).rejects.toThrow('Match not found');\n  });\n\n  test('should emit events for match lifecycle', (done) => {\n    let eventsReceived = 0;\n    const expectedEvents = ['match:created', 'action:executed', 'match:completed'];\n    \n    expectedEvents.forEach(event => {\n      gameClient.on(event as any, () => {\n        eventsReceived++;\n        if (eventsReceived === expectedEvents.length) {\n          done();\n        }\n      });\n    });\n    \n    gameClient.initialize().then(async () => {\n      const { match } = await gameClient.createMatch(players);\n      \n      const action: GameAction = {\n        type: ActionType.Move,\n        player: players[0],\n        data: {},\n        timestamp: Date.now()\n      };\n      \n      await gameClient.executeGameAction(match.id.toString(), action);\n      await gameClient.selectMatchWinners(match.id.toString(), 1);\n    });\n  }, 5000);\n\n  test('should handle client status and metrics', async () => {\n    await gameClient.initialize();\n    \n    const { match } = await gameClient.createMatch(players);\n    \n    const status = gameClient.getStatus();\n    \n    expect(status.isInitialized).toBe(true);\n    expect(status.activeMatches).toBe(1);\n    expect(status.activePlayers).toBe(2);\n    expect(status.rollupSessions).toBe(1);\n    expect(status.magicBlock).toBeDefined();\n    expect(status.vrfMetrics).toBeDefined();\n  });\n});"