/**\n * Utility Functions Tests\n */\n\nimport { PublicKey } from '@solana/web3.js';\nimport {\n  ValidationUtils,\n  CryptoUtils,\n  FormatUtils,\n  TimeUtils,\n  ArrayUtils,\n  PerfUtils,\n  ErrorUtils\n} from '../src/utils/helpers';\nimport { ECVRF } from '../src/vrf/ecvrf';\nimport { TEEAttestationVerifier } from '../src/tee/attestation';\nimport { RollupVerifier } from '../src/proof/rollup-verifier';\n\ndescribe('Validation Utils', () => {\n  test('should validate public keys', () => {\n    const validKey = '11111111111111111111111111111112'; // Valid base58\n    const invalidKey = 'invalid-key';\n    \n    expect(ValidationUtils.isValidPublicKey(validKey)).toBe(true);\n    expect(ValidationUtils.isValidPublicKey(invalidKey)).toBe(false);\n    expect(ValidationUtils.isValidPublicKey(new PublicKey(validKey))).toBe(true);\n  });\n\n  test('should validate VRF proof format', () => {\n    const keyPair = ECVRF.generateKeyPair();\n    const message = new TextEncoder().encode('test');\n    const output = ECVRF.prove(keyPair.secretKey, message);\n    \n    expect(ValidationUtils.isValidVRFProof(output.proof)).toBe(true);\n    \n    const invalidProof = { ...output.proof, gamma: new Uint8Array(10) };\n    expect(ValidationUtils.isValidVRFProof(invalidProof)).toBe(false);\n  });\n\n  test('should validate TEE attestation format', () => {\n    const validAttestation = TEEAttestationVerifier.createTestAttestation();\n    expect(ValidationUtils.isValidTEEAttestation(validAttestation)).toBe(true);\n    \n    const invalidAttestation = { ...validAttestation, quote: new Uint8Array(10) };\n    expect(ValidationUtils.isValidTEEAttestation(invalidAttestation)).toBe(false);\n  });\n\n  test('should validate rollup proof format', () => {\n    const validProof = RollupVerifier.createTestProof(1);\n    expect(ValidationUtils.isValidRollupProof(validProof)).toBe(true);\n    \n    const invalidProof = { ...validProof, stateRoot: new Uint8Array(10) };\n    expect(ValidationUtils.isValidRollupProof(invalidProof)).toBe(false);\n  });\n});\n\ndescribe('Crypto Utils', () => {\n  test('should generate random bytes', () => {\n    const bytes = CryptoUtils.randomBytes(32);\n    \n    expect(bytes).toBeInstanceOf(Uint8Array);\n    expect(bytes.length).toBe(32);\n    \n    // Should be different each time\n    const bytes2 = CryptoUtils.randomBytes(32);\n    expect(bytes).not.toEqual(bytes2);\n  });\n\n  test('should hash data', () => {\n    const data = new TextEncoder().encode('test data');\n    const hash = CryptoUtils.hash(data);\n    \n    expect(hash).toBeInstanceOf(Uint8Array);\n    expect(hash.length).toBe(64); // SHA-512 output\n    \n    // Same input should produce same hash\n    const hash2 = CryptoUtils.hash(data);\n    expect(hash).toEqual(hash2);\n  });\n\n  test('should perform constant time comparison', () => {\n    const a = new Uint8Array([1, 2, 3, 4]);\n    const b = new Uint8Array([1, 2, 3, 4]);\n    const c = new Uint8Array([1, 2, 3, 5]);\n    \n    expect(CryptoUtils.constantTimeCompare(a, b)).toBe(true);\n    expect(CryptoUtils.constantTimeCompare(a, c)).toBe(false);\n    expect(CryptoUtils.constantTimeCompare(a, new Uint8Array([1, 2, 3]))).toBe(false);\n  });\n\n  test('should convert bytes to/from hex', () => {\n    const bytes = new Uint8Array([0, 15, 255, 128]);\n    const hex = CryptoUtils.bytesToHex(bytes);\n    \n    expect(hex).toBe('000fff80');\n    \n    const backToBytes = CryptoUtils.hexToBytes(hex);\n    expect(backToBytes).toEqual(bytes);\n  });\n\n  test('should XOR byte arrays', () => {\n    const a = new Uint8Array([1, 2, 3, 4]);\n    const b = new Uint8Array([4, 3, 2, 1]);\n    const result = CryptoUtils.xor(a, b);\n    \n    expect(result).toEqual(new Uint8Array([5, 1, 1, 5]));\n    \n    expect(() => {\n      CryptoUtils.xor(a, new Uint8Array([1, 2]));\n    }).toThrow('Arrays must have same length');\n  });\n});\n\ndescribe('Format Utils', () => {\n  test('should format public key', () => {\n    const pubkey = new PublicKey('11111111111111111111111111111112');\n    const formatted = FormatUtils.formatPublicKey(pubkey);\n    \n    expect(formatted).toMatch(/^.{8}\\.\\.\\..{8}$/);\n  });\n\n  test('should format SOL amounts', () => {\n    expect(FormatUtils.formatSOL(1_000_000_000)).toBe('1.000000 SOL');\n    expect(FormatUtils.formatSOL(500_000_000)).toBe('0.500000 SOL');\n    expect(FormatUtils.formatSOL(1_000)).toBe('0.000001 SOL');\n  });\n\n  test('should format duration', () => {\n    expect(FormatUtils.formatDuration(500)).toBe('500ms');\n    expect(FormatUtils.formatDuration(1500)).toBe('1.50s');\n    expect(FormatUtils.formatDuration(65000)).toBe('1.08m');\n    expect(FormatUtils.formatDuration(3700000)).toBe('1.03h');\n  });\n\n  test('should format bytes', () => {\n    expect(FormatUtils.formatBytes(1024)).toBe('1.00 KB');\n    expect(FormatUtils.formatBytes(1536)).toBe('1.50 KB');\n    expect(FormatUtils.formatBytes(1048576)).toBe('1.00 MB');\n    expect(FormatUtils.formatBytes(500)).toBe('500.00 B');\n  });\n\n  test('should format percentages', () => {\n    expect(FormatUtils.formatPercentage(0.5)).toBe('50.00%');\n    expect(FormatUtils.formatPercentage(0.123)).toBe('12.30%');\n    expect(FormatUtils.formatPercentage(1.0)).toBe('100.00%');\n  });\n\n  test('should format large numbers', () => {\n    expect(FormatUtils.formatNumber(1500)).toBe('1.5K');\n    expect(FormatUtils.formatNumber(1500000)).toBe('1.5M');\n    expect(FormatUtils.formatNumber(500)).toBe('500');\n    expect(FormatUtils.formatNumber(12500)).toBe('12.5K');\n  });\n});\n\ndescribe('Time Utils', () => {\n  test('should get current timestamp', () => {\n    const now = TimeUtils.now();\n    expect(typeof now).toBe('number');\n    expect(now).toBeGreaterThan(0);\n  });\n\n  test('should sleep for specified time', async () => {\n    const start = Date.now();\n    await TimeUtils.sleep(50);\n    const end = Date.now();\n    \n    expect(end - start).toBeGreaterThanOrEqual(45); // Allow some variance\n  });\n\n  test('should handle timeout', async () => {\n    await expect(TimeUtils.timeout(10, 'Test timeout'))\n      .rejects.toThrow('Test timeout');\n  });\n\n  test('should race with timeout', async () => {\n    const fastPromise = Promise.resolve('fast');\n    const result = await TimeUtils.withTimeout(fastPromise, 100);\n    expect(result).toBe('fast');\n    \n    const slowPromise = TimeUtils.sleep(200).then(() => 'slow');\n    await expect(TimeUtils.withTimeout(slowPromise, 50))\n      .rejects.toThrow('Operation timed out');\n  });\n\n  test('should check expiry', () => {\n    const now = Date.now();\n    const oldTimestamp = now - 10000; // 10 seconds ago\n    const futureTimestamp = now + 10000; // 10 seconds in future\n    \n    expect(TimeUtils.isExpired(oldTimestamp, 5000)).toBe(true);\n    expect(TimeUtils.isExpired(oldTimestamp, 15000)).toBe(false);\n    expect(TimeUtils.isExpired(futureTimestamp, 5000)).toBe(false);\n  });\n\n  test('should convert time units', () => {\n    expect(TimeUtils.secondsToMs(1)).toBe(1000);\n    expect(TimeUtils.minutesToMs(1)).toBe(60000);\n    expect(TimeUtils.hoursToMs(1)).toBe(3600000);\n  });\n});\n\ndescribe('Array Utils', () => {\n  test('should shuffle arrays', () => {\n    const original = [1, 2, 3, 4, 5];\n    const shuffled = ArrayUtils.shuffle(original);\n    \n    expect(shuffled).toHaveLength(5);\n    expect(shuffled.sort()).toEqual([1, 2, 3, 4, 5]);\n    expect(original).toEqual([1, 2, 3, 4, 5]); // Original unchanged\n  });\n\n  test('should remove duplicates', () => {\n    const withDupes = [1, 2, 2, 3, 3, 3, 4];\n    const unique = ArrayUtils.unique(withDupes);\n    \n    expect(unique).toEqual([1, 2, 3, 4]);\n  });\n\n  test('should chunk arrays', () => {\n    const array = [1, 2, 3, 4, 5, 6, 7];\n    const chunks = ArrayUtils.chunk(array, 3);\n    \n    expect(chunks).toEqual([[1, 2, 3], [4, 5, 6], [7]]);\n  });\n\n  test('should get random elements', () => {\n    const array = [1, 2, 3, 4, 5];\n    const element = ArrayUtils.randomElement(array);\n    \n    expect(array).toContain(element);\n    \n    const elements = ArrayUtils.randomElements(array, 3);\n    expect(elements).toHaveLength(3);\n    expect(new Set(elements).size).toBe(3); // No duplicates\n  });\n});\n\ndescribe('Performance Utils', () => {\n  test('should measure function execution time', async () => {\n    const testFn = async () => {\n      await TimeUtils.sleep(10);\n      return 'result';\n    };\n    \n    const { result, duration } = await PerfUtils.measure(testFn);\n    \n    expect(result).toBe('result');\n    expect(duration).toBeGreaterThan(5);\n  });\n\n  test('should benchmark function', async () => {\n    const testFn = () => {\n      let sum = 0;\n      for (let i = 0; i < 1000; i++) {\n        sum += i;\n      }\n      return sum;\n    };\n    \n    const benchmark = await PerfUtils.benchmark(testFn, 10);\n    \n    expect(benchmark.averageMs).toBeGreaterThan(0);\n    expect(benchmark.minMs).toBeGreaterThan(0);\n    expect(benchmark.maxMs).toBeGreaterThanOrEqual(benchmark.minMs);\n    expect(benchmark.totalMs).toBeGreaterThan(0);\n  });\n\n  test('should throttle function calls', (done) => {\n    let callCount = 0;\n    const fn = () => { callCount++; };\n    const throttled = PerfUtils.throttle(fn, 50);\n    \n    throttled();\n    throttled();\n    throttled();\n    \n    expect(callCount).toBe(1);\n    \n    setTimeout(() => {\n      throttled();\n      expect(callCount).toBe(2);\n      done();\n    }, 60);\n  });\n\n  test('should debounce function calls', (done) => {\n    let callCount = 0;\n    const fn = () => { callCount++; };\n    const debounced = PerfUtils.debounce(fn, 50);\n    \n    debounced();\n    debounced();\n    debounced();\n    \n    expect(callCount).toBe(0);\n    \n    setTimeout(() => {\n      expect(callCount).toBe(1);\n      done();\n    }, 60);\n  });\n});\n\ndescribe('Error Utils', () => {\n  test('should check error types', () => {\n    const error = new Error('test');\n    error.name = 'TestError';\n    \n    expect(ErrorUtils.isErrorType(error, 'TestError')).toBe(true);\n    expect(ErrorUtils.isErrorType(error, 'OtherError')).toBe(false);\n  });\n\n  test('should extract error messages', () => {\n    expect(ErrorUtils.getErrorMessage(new Error('test'))).toBe('test');\n    expect(ErrorUtils.getErrorMessage('string error')).toBe('string error');\n    expect(ErrorUtils.getErrorMessage(null)).toBe('Unknown error');\n  });\n\n  test('should create errors with context', () => {\n    const error = ErrorUtils.createError('test message', 'TEST_CODE', { foo: 'bar' }) as any;\n    \n    expect(error.message).toBe('test message');\n    expect(error.code).toBe('TEST_CODE');\n    expect(error.context).toEqual({ foo: 'bar' });\n  });\n\n  test('should retry with exponential backoff', async () => {\n    let attempts = 0;\n    const failingFn = async () => {\n      attempts++;\n      if (attempts < 3) {\n        throw new Error('fail');\n      }\n      return 'success';\n    };\n    \n    const result = await ErrorUtils.retry(failingFn, 3, 1);\n    \n    expect(result).toBe('success');\n    expect(attempts).toBe(3);\n  });\n\n  test('should throw after max retries', async () => {\n    const alwaysFailsFn = async () => {\n      throw new Error('always fails');\n    };\n    \n    await expect(ErrorUtils.retry(alwaysFailsFn, 2, 1))\n      .rejects.toThrow('always fails');\n  });\n});"